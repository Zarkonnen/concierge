<!DOCTYPE html>
<html style="margin: 0; padding: 0;">
    <head>
        <title>Concierge</title>
        <script src="jquery-3.1.1.min.js"></script>
        <script src="howler.min.js"></script>
    </head>
    <body style="margin: 0; padding: 0; background: #333333;">
        <canvas width="800" height="600" allowfullscreen="true" id="gameCanvas" style="margin-left: 10px; margin-top: 10px;"></canvas>
        <script>
var peopleList = [
    {
        id: "spy",
        head: "spyhead",
        activeHead: "spyactivehead",
        deadHead: "spydeadhead",
        body: "spybody",
        activeTool: "spygun",
        name: "Septimus Smith",
        intro: "The name's Smith. Septimus Smith.",
        animation: "standing",
        animationT: 0,
        x: 0,
        y: 0,
        active: false,
        strength: 4,
        alive: true,
        stealable: "suitcase",
        rampageForStolenItem: true,
        priority: 100,
        moveTo: 1
    },
    {
        id: "werewolf",
        head: "werewolfhead",
        activeHead: "werewolfactivehead",
        deadHead: "werewolfdeadhead",
        body: "werewolfbody",
        activeBody: "werewolfactivebody",
        activeTool: "werewolfclaw",
        name: "U.P. Garoul",
        intro: "Lovely moon tonight, er, right?",
        animation: "standing",
        animationT: 0,
        x: 0,
        y: 0,
        active: false,
        alive: true,
        moved: false,
        neutralized: false,
        priority: 70,
        moveTo: -1,
        attacks: true,
        strength: 3
    },
    {
        id: "murderer",
        head: "murdererhead",
        activeHead: "murdereractivehead",
        deadHead: "murdererdeadhead",
        body: "murdererbody",
        activeTool: "murdereraxe",
        name: "Mr. Grushko",
        intro: "I am Mister Grushko. One room, please.",
        animation: "standing",
        animationT: 0,
        x: 0,
        y: 0,
        active: false,
        strength: 5,
        alive: true,
        neutralized: false,
        moved: false,
        stealable: "murdereraxe",
        stealingNeutralizes: true,
        attacks: true,
        moveTo: 2,
        priority: 90
    },
    {
        id: "suicide",
        head: "suicidehead",
        activeHead: "suicideactivehead",
        deadHead: "suicidedeadhead",
        body: "suicidebody",
        activeTool: "suicidegun",
        name: "Werther Junge",
        intro: "It's OK if I pay in the morning, right?",
        animation: "standing",
        animationT: 0,
        x: 0,
        y: 0,
        active: false,
        strength: 1,
        alive: true,
        stealable: "suicidegun",
        stealingNeutralizes: true,
        suicides: true,
        priority: 110
    },
    {
        id: "cultist",
        head: "cultisthead",
        activeHead: "cultistactivehead",
        deadHead: "cultistdeadhead",
        body: "cultistbody",
        activeBody: "cultistactivebody",
        activeTool: "cultiststaff",
        name: "Philippa Marsh",
        intro: "Greetings. Is my room ready?",
        animation: "standing",
        animationT: 0,
        x: 0,
        y: 0,
        active: false,
        strength: 1,
        alive: true,
        stealable: "cultiststaff",
        stealingNeutralizes: true,
        priority: 40,
        summons: true,
        disturbanceNeutralizes: true
    },
    {
        id: "snorer",
        head: "snorerhead",
        activeHead: "snoreractivehead",
        deadHead: "snorerdeadhead",
        body: "snorerbody",
        name: "Mr. O'Doul",
        intro: "Can't wait for a good night's sleep, eh?",
        animation: "standing",
        animationT: 0,
        x: 0,
        y: 0,
        active: false,
        strength: 1,
        alive: true,
        snores: true,
        priority: 50
    },
    {
        id: "granny",
        head: "grannyhead",
        deadHead: "grannydeadhead",
        body: "grannybody",
        name: "Mrs. Spelt",
        intro: "Hello, dearie.",
        animation: "standing",
        animationT: 0,
        x: 0,
        y: 0,
        active: false,
        strength: 7,
        alive: true
    },
    {
        id: "priest",
        head: "priesthead",
        deadHead: "priestdeadhead",
        body: "priestbody",
        activeTool: "priestcross",
        name: "Father Rumbucket",
        intro: "Hello.",
        animation: "standing",
        animationT: 0,
        x: 0,
        y: 0,
        active: false,
        strength: 1,
        alive: true,
        neutralizes: {werewolf: 1, vampire: 1},
        stealable: "priestcross",
        neutralized: false,
        stealingNeutralizes: true
    },
    {
        id: "vamp",
        head: "vamphead",
        activeHead: "vampactivehead",
        deadHead: "vampdeadhead",
        body: "vampbody",
        activeBody: "vampactivebody",
        name: "Raquelle",
        intro: "Hi! *giggles*",
        animation: "standing",
        animationT: 0,
        x: 0,
        y: 0,
        active: false,
        strength: 1,
        alive: true,
        moveTo: 3,
        fucks: true,
        priority: 80,
        winsOverVampire: true
    },
    {
        id: "vampire",
        head: "vampirehead",
        activeHead: "vampireactivehead",
        deadHead: "vampiredeadhead",
        body: "vampirebody",
        name: "A.L. Ucard",
        intro: "Hello, my friend. One room please. I won't be needing dinner.",
        animation: "standing",
        animationT: 0,
        introParticles: {
            color: "black",
            number: 100,
            size: 80,
            speed: 0.5,
            life: 500
        },
        x: 0,
        y: 0,
        active: false,
        strength: 6,
        alive: true,
        killsIntruders: true,
        priority: 60,
        feeds: true,
        moveTo: -1
    },
    {
        id: "thief",
        head: "thiefhead",
        deadHead: "thiefdeadhead",
        body: "thiefbody",
        activeTool: "thiefcrowbar",
        name: "T. Felofavan", // It fell off a van
        intro: "Lovely hotel you've got here.",
        animation: "standing",
        animationT: 0,
        x: 0,
        y: 0,
        active: false,
        strength: 1,
        alive: true,
        steals: true,
        priority: 30,
        moveTo: 1
    },
    {
        id: "insomniac",
        head: "insomniachead",
        activeHead: "insomniacactivehead",
        deadHead: "insomniacdeadhead",
        body: "insomniacbody",
        activeTool: "insomniacknife",
        name: "S. Onpyh",
        intro: "I'd like your quietest room.",
        animation: "standing",
        animationT: 0,
        x: 0,
        y: 0,
        active: false,
        strength: 2,
        alive: true,
        disturbanceActivates: true,
        rampagesIfActivated: true,
        moveTo: -1
    },
];
var people = {};
for (var i = 0; i < peopleList.length; i++) {
    people[peopleList[i].id] = peopleList[i];
}

// State
var splash = true;
var night = false;
var intro = true;
var epilogue = false;
var managerOut = true;
var introLine = 0;
var introLines = ["I'm sick of you re-assigning guests for trivial reasons!", "In this hotel, each guest gets one room and stays in it!", "And those terrible deaths in recent weeks...", "We can afford no more negative press, no more corpses in our rooms.", "Now get to work - I see today's first guest coming in."];
var epilogueLines = [
    "Everyone is dead! How could this happen?",
    "One survivor? What happened?",
    "Nearly everyone died in the night - we are ruined!",
    "Half the guests died! Our reputation is in tatters!",
    "Two guests dead? What a terrible tragedy!",
    "Another guest died? What an unfortunate event!",
    "Glad to see the night went quietly. Keep up the good work."
];
var assignGuest = false;
var guestWait = 0;
var managerX = 0;
var manager = {
    head: "managerhead",
    body: "managerbody",
    animation: "talking",
    animationT: 0,
    alive: true
};
var guestIDs = {};
var guest = pickGuest();
var guestSaidHello = false;
var animating = null;
var turnGuest = null;
var turnGuestRoom = null;
var targetRoom = null;
var moving = null;
var movingFrom = null;
var movingTo = null;
var movingToRight = false;
var movingToState = 0;
var toKill = null;
var toNeutralize = null;
var postAnimWait = 0;
var deactivatePostAnim = false;
var activatePostAnim = false;
var emitTick = 0;
var toDisturbRoomIndexes = [];
var particles = [];
var apocalypse = false;
var tentacle = null;
var tentacleX = 0;
var tentacleY = 0;
var rooms = [
    {
        name: "Room 1",
        x: 256,
        y: 31.5,
        w: 182,
        h: 242,
        occupant: null,
        bottom: false
    },
    {
        name: "Room 2",
        x: 256 + 205,
        y: 31.5,
        w: 182,
        h: 242,
        occupant: null,
        bottom: false
    },
    {
        name: "Room 3",
        x: 256 + 205 * 2,
        y: 31.5,
        w: 182,
        h: 242,
        occupant: null,
        bottom: false
    },
    {
        name: "Room 4",
        x: 256 + 205 * 2,
        y: 426.5,
        w: 182,
        h: 242,
        occupant: null,
        bottom: true
    },
    {
        name: "Room 5",
        x: 256 + 205,
        y: 426.5,
        w: 182,
        h: 242,
        occupant: null,
        bottom: true
    },
    {
        name: "Room 6",
        x: 256,
        y: 426.5,
        w: 182,
        h: 242,
        occupant: null,
        bottom: true
    }
];

function numSurvivors() {
    var n = 0;
    for (var i = 0; i < rooms.length; i++) {
        if (rooms[i].occupant.alive) { n++; }
    }
    return n;
}

function instaNight() {
    guestIDs = {};
    for (var i = 0; i < rooms.length; i++) {
        var room = rooms[i];
        room.occupant = pickGuest();
        room.occupant.x = room.x + room.w / 4;
        room.occupant.y = room.y + room.h / 2;
    }
    night = true;
}

function isFull() {
    for (var i = 0; i < rooms.length; i++) {
        if (!rooms[i].occupant) { return false; }
    }
    return true;
}

function pickGuest() {
    var ids = peopleList.map(function(p) { return p.id; }).filter(function(id) { return !guestIDs[id]; });
    var guestID = ids[Math.floor(Math.random() * ids.length)];
    if (!guestIDs.cultist) {
        guestID = "cultist";
    } else if (!guestIDs.granny) {
        guestID = "granny";
    }
    /* else if (!guestIDs.vamp) {
        guestID = "vamp";
    }*/
    guestIDs[guestID] = 1;
    var guest = people[guestID];
    animate(guest, guest.introParticles ? "standing" : "walking");
    return guest;
}

function animate(person, animation) {
    person.animation = animation;
    person.animationT = 0;
}

function animTick(person, ms) {
    person.animationT += ms;
    if (person.animationT > animLengths[person.animation]) {
        person.xFlipForAnimation = false;
        person.animation = "standing";
        person.animationT = 0;
        return null;
    }
    return person;
}

function doAnim(person, animation) {
    animate(person, animation);
    animating = person;
    postAnimWait = animation == "killing" || animation == "neutralizing" || animation == "seducing" ? 0 : 500;
}

var MT_START = 0;
var MT_SRC_CENTER = 1;
var MT_SRC_CORRIDOR = 2;
var MT_TRG_CORRIDOR = 3;
var MT_TRG_CENTER = 4;
var MT_END = 5;

function kill(person) {
    toKill = person;
}

function tentacleKill(person) {
    tentacle = "tentacle" + Math.floor(Math.random() * 2);
    tentacleX = person.x;
    tentacleY = 800;
    toKill = person;
}

function neutralize(person) {
    toNeutralize = person;
}

function doMove(person, from, room, right) {
    animate(person, "moving");
    animating = person;
    moving = person;
    movingFrom = from;
    movingTo = room;
    movingToRight = right;
    movingToState = MT_START;
    postAnimWait = 500;
}

function input(ms) {
    if (splash) {
        if (click) {
            splash = false;
            click = null;
        }
        return;
    }
    /*if (!night) {
        instaNight();
        return;
    }*/
    if (night) {
        // Just watch.
    } else if (assignGuest) {
        if (click) {
            for (var i = 0; i < rooms.length; i++) {
                var room = rooms[i];
                if (!room.occupant && click.x / scale > room.x + w / 2 - 500 && click.x / scale < room.x + room.w + w / 2 - 500 && click.y / scale > room.y && click.y / scale < room.y + room.h) {
                    room.occupant = guest;
                    guest.x = room.x + room.w / 4;
                    guest.y = room.y + room.h / 2;
                    if (isFull()){
                        guest = null;
                        assignGuest = false;
                        night = true;
                    } else {
                        guest = pickGuest();
                        guestWait = 500;
                        assignGuest = false;
                        guestSaidHello = false;
                    }
                }
            }
        }
    } else {
        if (intro) {
            if (click) {
                introLine++;
                if (introLine >= introLines.length) {
                    intro = false;
                    return;
                }
                animate(manager, "talking");
            }
        } else if (managerOut) {
            managerX += ms * 2;
            if (managerX > 1200) {
                managerOut = false;
                guestWait = 500;
            }
        } else if (guestWait == 0 && !guestSaidHello) {
            guestSaidHello = true;
            animate(guest, "talking");
        } else if (guestWait == 0 && guestSaidHello && click && cursor.x / scale > w / 2 - 100 && cursor.x / scale < w / 2 + 100 && cursor.y / scale > 600 && cursor.y / scale < 650) {
            assignGuest = true;
        }
    }
    click = null;
}

function doesActivate(occupant) {
    return occupant.fucks || occupant.feeds || occupant.summons || occupant.snores || occupant.attacks || occupant.steals || occupant.suicides || (occupant.rampageForStolenItem && occupant.stolenFrom);
}

function disturbNearby(actor, room) {
    toDisturbRoomIndexes = [
        (rooms.indexOf(room) + rooms.length + 1) % rooms.length,
        (rooms.indexOf(room) + rooms.length - 1) % rooms.length
    ];
    console.log(actor.id + " disturbing rooms of " + rooms[toDisturbRoomIndexes[0]].occupant.id + " and " + rooms[toDisturbRoomIndexes[1]].occupant.id);
}

function update(ms) {
    emitTick++;
    for (var i = 0; i < particles.length; i++) {
        var p = particles[i];
        p.life -= ms;
        p.x += p.dx * ms;
        p.y += p.dy * ms;
        if (p.life <= 0) {
            particles.splice(i, 1);
            i--;
        }
    }
    if (epilogue) {
        animTick(manager, ms);
    } else if (night) {
        if (people.vampire != animating) {
            animTick(people.vampire, ms);
        }
        if (people.cultist != animating) {
            animTick(people.cultist, ms);
            if (people.cultist.animation == "summoning" && emitTick % 4 == 0) {
                var angle = Math.random() * Math.PI * 2;
                var dist = Math.random() * 20;
                var speed = Math.random() * 0.1 + 0.1;
                particles.push({
                    color: "#00d224",
                    size: 5,
                    x: people.cultist.x - 35 + Math.cos(angle) * dist,
                    y: people.cultist.y - 25 + Math.sin(angle) * dist,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    life: 100 + Math.random() * 200
                });
            }
            if (people.cultist.animation == "summoning" && emitTick % 17 == 0) {
                var angle = Math.random() * Math.PI * 2;
                var dist = Math.random() * 10;
                particles.push({
                    color: "#00d224",
                    size: 10,
                    x: people.cultist.x - 35 + Math.cos(angle) * dist,
                    y: people.cultist.y - 23 + Math.sin(angle) * dist,
                    dx: 0,
                    dy: 0,
                    life: 500 + Math.random() * 300
                });
            }
            if (people.cultist.animation == "summoning" && emitTick % 209 == 0) {
                particles.push({
                    color: "#ffffff",
                    letter: ["Fhtagn!", "Cthulhu!", "Dagon!", "Shub-Niggurath!", "Fnord!"][Math.floor(Math.random() * 5)],
                    size: 30,
                    x: people.cultist.x,
                    y: people.cultist.y - 40,
                    dx: 0,
                    dy: -0.07,
                    life: 2000
                });
            }
        }
        if (tentacle != null) {
            tentacleY -= ms;
            if (tentacleY <= toKill.y) {
                tentacle = null;
            }
            return;
        } else if (animating) {
            var a = animating;
            var currentAnim = animating.animation;
            animating = animTick(animating, ms);
            if (!animating && deactivatePostAnim) {
                a.active = false;
                deactivatePostAnim = false;
            }
            if (!animating && activatePostAnim) {
                a.active = true;
                activatePostAnim = false;
            }
            if (!animating && currentAnim == "seducing") {
                doAnim(a, "moving");
            }
            if (animating && currentAnim == "snoring" && emitTick % 50 == 0) {
                particles.push({
                    color: "#ffffff",
                    letter: "Z",
                    size: 30,
                    x: animating.x,
                    y: animating.y - 40,
                    dx: 0,
                    dy: -0.07,
                    life: 2000
                });
            }
            if (animating && currentAnim == "fucking" && emitTick % 70 == 0) {
                particles.push({
                    color: "#ffffff",
                    letter: "Oh!",
                    size: 30,
                    x: animating.x,
                    y: animating.y - 40,
                    dx: 0,
                    dy: -0.07,
                    life: 2000
                });
            }
            if (moving && !(animating && animating.animation == "seducing")) {
                var tx = 0;
                var ty = 0;
                switch (movingToState) {
                    case MT_START:
                        tx = movingFrom.x + movingFrom.w / 2;
                        ty = movingFrom.bottom ? (movingFrom.y + movingFrom.h * 1 / 4) : (movingFrom.y + movingFrom.h * 3 / 4);
                        break;
                    case MT_SRC_CENTER:
                        tx = movingFrom.x + movingFrom.w / 2;
                        ty = 350;
                        break;
                    case MT_SRC_CORRIDOR:
                        tx = movingTo.x + movingTo.w / 2;
                        ty = 350;
                        break;
                    case MT_TRG_CORRIDOR:
                        tx = movingTo.x + movingTo.w / 2;
                        ty = movingTo.bottom ? (movingTo.y + movingTo.h * 1 / 4) : (movingTo.y + movingTo.h * 3 / 4);
                        break;
                    case MT_TRG_CENTER:
                        tx = movingToRight ? (movingTo.x + movingTo.w * 3 / 4) : (movingTo.x + movingTo.w * 1 / 4);
                        ty = movingTo.y + movingTo.h / 2;
                        break;
                    case MT_END:
                        break;
                }
                var spd = ms * 0.13;
                var distSq = (moving.x - tx) * (moving.x - tx) + (moving.y - ty) * (moving.y - ty);
                if (distSq < spd * spd) {
                    moving.x = tx;
                    moving.y = ty;
                    movingToState++;
                    if (movingToState == MT_TRG_CENTER && moving.fucks && !moving.seduced) {
                        doAnim(moving, "seducing");
                        moving.seduced = true;
                        console.log("seductive wiggle");
                        return;
                    }
                    if (movingToState == MT_TRG_CENTER && people.vampire.feedingRoom == movingTo) {
                        console.log("vampire interrupted at snack, murders");
                        animating = null;
                        kill(moving);
                        moving = null;
                        turnGuest = null;
                        targetRoom = null;
                        return;
                    }
                    if (movingToState == MT_END) {
                        animate(moving, "standing");
                        animating = null;
                        moving = null;
                    }
                } else {
                    var angle = Math.atan2(ty - moving.y, tx - moving.x);
                    moving.x += Math.cos(angle) * spd;
                    moving.y += Math.sin(angle) * spd;
                }
            }
        } else if (postAnimWait > 0) {
            postAnimWait -= ms;
        } else if (toKill) {
            toKill.alive = false;
            animate(toKill, "standing");
            for (var i = 0; i < 30; i++) {
                var angle = Math.random() * Math.PI * 2;
                var dist = Math.random() * 20;
                var speed = Math.random() * 0.5;
                particles.push({
                    color: "#cf0000",
                    size: 30,
                    x: toKill.x + Math.cos(angle) * dist,
                    y: toKill.y + Math.sin(angle) * dist,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    life: 500 * Math.random()
                });
            }
            postAnimWait = 1000;
            toKill = null;
        } else if (toNeutralize) {
            toNeutralize.neutralized = true;
            if (toNeutralize.active) {
                toNeutralize.active = false;
                doAnim(toNeutralize, "deactivating");
            }
            postAnimWait = 500;
            toNeutralize = null;
        } else if (apocalypse) {
            if (numSurvivors == 0) {
                apocalypse = false;
            } else {
                for (var i = 0; i < rooms.length; i++) {
                    if (rooms[i].occupant.alive) {
                        tentacleKill(rooms[i].occupant);
                        return;
                    }
                }
            }
        } else {
            if (!turnGuest) {
                if (toDisturbRoomIndexes.length > 0) {
                    console.log("Processing disturbances.");
                    var room = rooms[toDisturbRoomIndexes[0]];
                    toDisturbRoomIndexes.splice(0, 1);
                    if (room.occupant.alive && !room.occupant.neutralized) {
                        if (room.occupant.disturbanceActivates) {
                            turnGuest = room.occupant;
                            turnGuestRoom = room;
                            console.log(turnGuest.id + " activated by disturbance");
                            return;
                        }
                        if (room.occupant.disturbanceNeutralizes) {
                            doAnim(room.occupant, "interrupted");
                            neutralize(room.occupant);
                            console.log(room.occupant.id + " neutralized by disturbance");
                            return;
                        }
                    }
                    return;
                }
                console.log("Finding next guest");
                for (var i = 0; i < rooms.length; i++) {
                    var occupant = rooms[i].occupant;
                    if (occupant.priority && !occupant.moved && occupant.alive && doesActivate(occupant) && (!turnGuest || occupant.priority < turnGuest.priority)) {
                        turnGuest = occupant;
                        turnGuestRoom = rooms[i];
                    }
                }
            }
            if (!turnGuest) {
                console.log("Turns done");
                if (people.vampire.alive && people.vampire.feeding && people.vampire.feedingRoom.occupant.alive) {
                    if (people.vampire.feedingRoom.occupant.winsOverVampire) {
                        console.log("The vampire stayed too late!");
                        kill(people.vampire);
                    } else {
                        console.log("The vampire kills!");
                        kill(people.vampire.feedingRoom.occupant);
                    }
                    return;
                }
                if (people.cultist.alive && people.cultist.moved && !people.cultist.neutralized) {
                    apocalypse = true;
                    return;
                }
                epilogue = true;
                managerX = 0;
                animate(manager, "talking");
                return;
            }
            if (!turnGuest.moved) {
                if (turnGuest.neutralized) {
                    console.log(turnGuest.id + " shrugging");
                    doAnim(turnGuest, "shrugging");
                    turnGuest.moved = true;
                    return;
                }
                if (!turnGuest.active) {
                    console.log(turnGuest.id + " activating");
                    if (turnGuest.snores) {
                        console.log(turnGuest.id + " snoring");
                        turnGuest.active = true;
                        doAnim(turnGuest, "snoring");
                        deactivatePostAnim = true;
                        turnGuest.moved = true;
                        disturbNearby(turnGuest, turnGuestRoom);
                    } else if (turnGuest.rampageForStolenItem || turnGuest.rampagesIfActivated) {
                        console.log(turnGuest.id + " is beginning to rampage");
                        activatePostAnim = true;
                        doAnim(turnGuest, "angry");
                    } else {
                        turnGuest.active = true;
                        doAnim(turnGuest, "activating");
                    }
                    return;
                }
                if (turnGuest.suicides) {
                    console.log(turnGuest.id + " commits suicide");
                    doAnim(turnGuest, "suicide");
                    kill(turnGuest);
                    disturbNearby(turnGuest, turnGuestRoom);
                    turnGuest = null;
                    return;
                }
                if (turnGuest.moveTo && !targetRoom) {
                    console.log(turnGuest.id + " moving");
                    targetRoom = rooms[(rooms.indexOf(turnGuestRoom) + turnGuest.moveTo + rooms.length) % rooms.length];
                    doMove(turnGuest, turnGuestRoom, targetRoom, true);
                    return;
                }
                if (turnGuest.feeds) {
                    if (!targetRoom.occupant.alive) {
                        console.log(turnGuest.id + " moves on to find a victim");
                        var oldTargetRoom = targetRoom;
                        targetRoom = rooms[(rooms.indexOf(targetRoom) + turnGuest.moveTo + rooms.length) % rooms.length];
                        if (targetRoom == turnGuestRoom) {
                            // Nothing to eat. Sad.
                            targetRoom = oldTargetRoom;
                            turnGuest.moved = true;
                            console.log(turnGuest.id + " done with trying to feed");
                            return;
                        }
                        doMove(turnGuest, oldTargetRoom, targetRoom, true);
                        return;
                    }
                    if (targetRoom.occupant.neutralizes && targetRoom.occupant.neutralizes[turnGuest.id]) {
                        console.log(turnGuest.id + " neutralized");
                        deactivatePostAnim = !targetRoom.occupant.active;
                        targetRoom.occupant.active = true;
                        targetRoom.occupant.xFlipForAnimation = true;
                        doAnim(targetRoom.occupant, "neutralizing");
                        neutralize(turnGuest);
                        turnGuest.moved = true;
                        return;
                    }
                    //targetRoom.occupant.neutralized = true;
                    neutralize(targetRoom.occupant);
                    turnGuest.feeding = true;
                    turnGuest.feedingRoom = targetRoom;
                    turnGuest.moved = true;
                    animate(turnGuest, "feeding");
                    return;
                }
                if (turnGuest.summons) {
                    console.log(turnGuest.id + " starts summoning");
                    animate(turnGuest, "summoning"); // In the BG
                    turnGuest.moved = true;
                    turnGuest = null;
                    postAnimWait = 2000;
                    return;
                }
                if (turnGuest.fucks) {
                    if (targetRoom.occupant.alive && !targetRoom.occupant.feeding) {
                        console.log(turnGuest.id + " fucking");
                        targetRoom.occupant.xFlipForAnimation = true;
                        doAnim(targetRoom.occupant, "fucking");
                        targetRoom.occupant.active = false;
                        targetRoom.occupant.neutralized = true;
                        disturbNearby(turnGuest, targetRoom);
                    }
                    turnGuest.moved = true;
                    return;
                }
                if (turnGuest.rampageForStolenItem || turnGuest.rampagesIfActivated) {
                    if (targetRoom.occupant.alive && !targetRoom.occupant.feeding) {
                        console.log(turnGuest.id + " attacking in rampage");
                        disturbNearby(turnGuest, targetRoom);
                        if (turnGuest.strength > targetRoom.occupant.strength || targetRoom.occupant.neutralized) {
                            console.log(turnGuest.id + " victory");
                            doAnim(turnGuest, "killing");
                            kill(targetRoom.occupant);
                        } else {
                            console.log(turnGuest.id + " defeat");
                            deactivatePostAnim = !targetRoom.occupant.active;
                            targetRoom.occupant.active = true;
                            targetRoom.occupant.xFlipForAnimation = true;
                            doAnim(targetRoom.occupant, "killing");
                            kill(turnGuest);
                            turnGuest = null;
                            targetRoom = null;
                        }
                        return;
                    }
                    if (turnGuest.rampageForStolenItem && targetRoom.occupant.stolenItem == turnGuest.stealable) {
                        console.log(turnGuest.id + " takes back the " + turnGuest.stealable);
                        turnGuest.moved = true;
                        turnGuest.stolenFrom = false;
                        turnGuest.stolenItem = turnGuest.stealable;
                        targetRoom.occupant.stolenItem = null;
                        doAnim(turnGuest, "stealing");
                        return;
                    }
                    console.log(turnGuest.id + " moving on in rampage");
                    var oldTargetRoom = targetRoom;
                    targetRoom = rooms[(rooms.indexOf(targetRoom) + turnGuest.moveTo + rooms.length) % rooms.length];
                    if (targetRoom == turnGuestRoom) {
                        // Nothing to steal. Sad.
                        targetRoom = oldTargetRoom;
                        turnGuest.moved = true;
                        console.log(turnGuest.id + " done with rampage");
                        return;
                    }
                    doMove(turnGuest, oldTargetRoom, targetRoom, true);
                    return;
                }
                if (targetRoom && turnGuest.steals) {
                    if (turnGuest.stolenItem) {
                        console.log(turnGuest.id + " returning from theft");
                        turnGuest.moved = true;
                        return;
                    }
                    if (targetRoom.occupant.alive && !targetRoom.occupant.neutralized && targetRoom.occupant.killsIntruders && !targetRoom.occupant.feeding) {
                        console.log(turnGuest.id + " killed by room occupant");
                        deactivatePostAnim = !targetRoom.occupant.active;
                        targetRoom.occupant.active = true;
                        targetRoom.occupant.xFlipForAnimation = true;
                        doAnim(targetRoom.occupant, "killing");
                        kill(turnGuest);
                        disturbNearby(targetRoom.occupant, targetRoom);
                        turnGuest = null;
                        targetRoom = null;
                        return;
                    }
                    if (!targetRoom.occupant.stealable) {
                        console.log(turnGuest.id + " nothing to steal in this room");
                        var oldTargetRoom = targetRoom;
                        targetRoom = rooms[(rooms.indexOf(targetRoom) + turnGuest.moveTo + rooms.length) % rooms.length];
                        if (targetRoom == turnGuestRoom) {
                            // Nothing to steal. Sad.
                            targetRoom = oldTargetRoom;
                            turnGuest.moved = true;
                            console.log(turnGuest.id + " giving up on theft");
                            return;
                        }
                        
                        doMove(turnGuest, oldTargetRoom, targetRoom, true);
                        return;
                    }
                    console.log(turnGuest.id + " stealing");
                    turnGuest.stolenItem = targetRoom.occupant.stealable;
                    targetRoom.occupant.stolenFrom = true;
                    if (targetRoom.occupant.stealingNeutralizes) {
                        targetRoom.occupant.neutralized = true;
                    }
                    doAnim(turnGuest, "stealing");
                    turnGuest.moved = true;
                }
                if (targetRoom && turnGuest.attacks) {
                    if (!targetRoom.occupant.alive || targetRoom.occupant.feeding) {
                        console.log(turnGuest.id + " no one to kill");
                        turnGuest.moved = true;
                        return;
                    }
                    console.log(turnGuest.id + " attacking");
                    if (targetRoom.occupant.neutralizes && targetRoom.occupant.neutralizes[turnGuest.id] && !targetRoom.occupant.neutralized) {
                        console.log(turnGuest.id + " neutralized");
                        deactivatePostAnim = !targetRoom.occupant.active;
                        targetRoom.occupant.active = true;
                        targetRoom.occupant.xFlipForAnimation = true;
                        doAnim(targetRoom.occupant, "neutralizing");
                        neutralize(turnGuest);
                        turnGuest.moved = true;
                    } else {
                        disturbNearby(turnGuest, targetRoom);
                        if (turnGuest.strength > targetRoom.occupant.strength || targetRoom.occupant.neutralized) {
                            console.log(turnGuest.id + " victory");
                            doAnim(turnGuest, "killing");
                            turnGuest.moved = true;
                            kill(targetRoom.occupant);
                        } else {
                            console.log(turnGuest.id + " defeat");
                            deactivatePostAnim = !targetRoom.occupant.active;
                            targetRoom.occupant.active = true;
                            targetRoom.occupant.xFlipForAnimation = true;
                            doAnim(targetRoom.occupant, "killing");
                            kill(turnGuest);
                            turnGuest = null;
                            targetRoom = null;
                        }
                    }
                    return;
                }
            } else {
                if (targetRoom) {
                    if (turnGuest.feeding) {
                        console.log("staying to feed");
                    } else {
                        console.log(turnGuest.id + " going home");
                        doMove(turnGuest, targetRoom, turnGuestRoom, false);
                    }
                    targetRoom = null;
                    return;
                }
                if (turnGuest.active && !turnGuest.feeding) {
                    console.log(turnGuest.id + " deactivating");
                    doAnim(turnGuest, "deactivating");
                    turnGuest.active = false;
                }
                console.log(turnGuest.id + " turn done");
                turnGuest = null;
                return;
            }
        }
    } else {
        if (guest) {
            animTick(guest, ms);
        }
        animTick(manager, ms);
        if (guestWait > 0) {
            guestWait = Math.max(0, guestWait - ms);
            if (guestWait == 0) {
                animate(guest, "standing");
                if (guest.introParticles) {
                    for (var i = 0; i < guest.introParticles.number; i++) {
                        var angle = Math.random() * Math.PI * 2;
                        var dist = Math.random() * 180;
                        var speed = guest.introParticles.speed * (Math.random() + 0.5);
                        particles.push({
                            color: guest.introParticles.color,
                            size: guest.introParticles.size,
                            x: w / 2 + Math.cos(angle) * dist,
                            y: h / 2 + Math.sin(angle) * dist,
                            dx: Math.cos(angle) * speed,
                            dy: Math.sin(angle) * speed,
                            life: guest.introParticles.life
                        });
                    }
                }
            }
        }
    }
}

var animLengths = {
    stealing: 600,
    shrugging: 400,
    activating: 385,
    deactivating: 385,
    walking: 100000,
    standing: 100000,
    summoning: 100000,
    feeding: 100000,
    killing: 500,
    neutralizing: 2000,
    seducing: 2000,
    angry: 1500,
    suicide: 3000,
    fucking: 3000,
    talking: 1550,
    snoring: 3500,
    interrupted: 3000
};

function person(person, x, y, active) {
    var bodyX = x;
    var bodyY = y + 110;
    var headX = x + 10;
    var headY = y - 110;
    var toolX = x - 160;
    var toolY = y - 20;
    var body = active && person.activeBody ? person.activeBody : person.body;
    var head = active && person.activeHead ? person.activeHead : person.head;
    var tool = active && person.activeTool ? person.activeTool : person.tool;
    var stolen = person.stolenItem;
    var stolenX = x + 100;
    var stolenY = y + 40;
    if (!person.alive) {
        body = "deadbody";
        head = person.deadHead;
        tool = null;
        bodyY -= 50;
        headY += 50;
    }
    var t = person.animationT;
    switch (person.animation) {
        case "feeding":
            headX -= 300 + Math.sin(t * 0.002) * 20;
            bodyX -= 300;
            toolX -= 300;
            stolenX -= 300;
            break;
        case "summoning":
            bodyX += Math.sin(t * 0.002) * 20;
            headX -= Math.sin(t * 0.002) * 20;
            toolX -= Math.sin(t * 0.002) * 40;
            break;
        case "interrupted":
            toolX = Math.sin(t * 0.1) * 20;
            break;
        case "stealing":
            stolenY = y + 120 - Math.sin(t * 0.002) * 250;
            break;
        case "shrugging":
            bodyY -= Math.max(0, Math.min(25, Math.sin(t * 0.01) * 50));
            break;
        case "activating":
            bodyY += Math.sin(t * 0.008) * 80;
            headY -= Math.sin(t * 0.008) * 80;
            if (t % 400 < 400 / 2) {
                body = person.body;
                head = person.head;
                tool = person.tool;
            } else {
                body = person.activeBody ? person.activeBody : person.body;
                head = person.activeHead ? person.activeHead : person.head;
                tool = person.activeTool ? person.activeTool : person.tool;
            }
            break;
        case "deactivating":
            bodyY += Math.sin(t * 0.008) * 80;
            headY -= Math.sin(t * 0.008) * 80;
            if (t % 400 > 400 / 2) {
                body = person.body;
                head = person.head;
                tool = person.tool;
            } else {
                body = person.activeBody ? person.activeBody : person.body;
                head = person.activeHead ? person.activeHead : person.head;
                tool = person.activeTool ? person.activeTool : person.tool;
            }
            break;
        case "moving":
            bodyY -= Math.abs(Math.sin(t * 0.01)) * 50;
            headY -= Math.abs(Math.sin(t * 0.01 + 0.2)) * 50;
            toolY -= Math.abs(Math.sin(t * 0.01 + 0.4)) * 50;
            break;
        case "killing":
            bodyX += Math.abs(Math.sin(t * 0.005)) * 10;
            toolX -= Math.abs(Math.sin(t * 0.005)) * 50;
            toolY += Math.abs(Math.sin(t * 0.005)) * 20;
            headY += Math.abs(Math.sin(t * 0.005)) * 10;
            break;
        case "neutralizing":
            toolX -= 40;
            toolY -= 40 + Math.sin(t * 0.005) * 10;
            headX -= Math.sin(t * 0.005) * 20;
            break;
        case "seducing":
            bodyX += Math.sin(t * 0.005) * 10;
            break;
        case "angry":
            headY -= Math.abs(Math.sin(t * 0.025)) * 20 - 30;
            toolX -= Math.abs(Math.sin(t * 0.025)) * 20 - 20;
            bodyX += Math.abs(Math.sin(t * 0.025)) * 5;
            break;
        case "fucking":
            bodyX -= Math.abs(Math.sin(t * Math.min(0.01, 0.004 + t * 0.000001))) * 50 - 20;
            headX += Math.abs(Math.sin(t * Math.min(0.01, 0.004 + t * 0.000001))) * 10 - 10;
            headY += 20;
            break;
        case "talking":
            headY -= Math.abs(Math.sin(t * 0.01)) * 20;
            break;
        case "suicide":
            toolY = Math.sin(t * 0.1) * 10;
            break;
        case "snoring":
            headY -= Math.sin(t * 0.001) * 40;
            bodyY -= Math.sin(t * 0.001) * 20;
            break;
    }
    img(body, bodyX, bodyY);
    img(head, headX, headY);
    img(tool, toolX, toolY);
    img(stolen, stolenX, stolenY);
}

var images = {};

function img(name, x, y) {
    if (name == null) { return; }
    if (!images[name]) {
        images[name] = new Image();
        images[name].src = "graphics/" + name + ".png";
    }
    var img = images[name];
    c.drawImage(img, x - img.width / 2, y - img.height / 2);
}

function text(text, x, y) {
    c.font = "18px Serif";
    var sz = c.measureText(text);
    var h = 18;
    c.fillStyle = "black";
    c.fillRect(x - sz.width / 2 - 12, y - h / 2 - 12, sz.width + 24, h + 24);
    c.fillStyle = "white";
    c.fillRect(x - sz.width / 2 - 10, y - h / 2 - 10, sz.width + 20, h + 20);
    c.fillStyle = "black";
    c.fillText(text, x - sz.width / 2, y + 6);
}

function whiteText(text, x, y) {
    c.font = "18px Serif";
    var sz = c.measureText(text);
    c.fillStyle = "white";
    c.fillText(text, x - sz.width / 2, y + 6);
}

function speech(speaker, text, x, y) {
    c.font = "18px Serif";
    var sz = c.measureText(text);
    var h = 18;
    c.fillStyle = "black";
    c.fillRect(x - sz.width / 2 - 12, y - h / 2 - 12, sz.width + 24, h + 24);
    var sz2 = c.measureText(speaker);
    c.fillRect(x - sz2.width / 2 - 12, y - h * 3 / 2 - 24, sz2.width + 24, h + 14);
    c.fillStyle = "white";
    c.fillRect(x - sz.width / 2 - 10, y - h / 2 - 10, sz.width + 20, h + 20);
    c.fillText(speaker, x - sz2.width / 2, y - h * 3 / 2 - 2);
    c.fillStyle = "black";
    c.fillText(text, x - sz.width / 2, y + 6);
}

var w = 0;
var h = 0;
var scale = 1.0;

function draw() {
    c.resetTransform();
    c.fillStyle = "#ddc3ac";
    c.fillRect(0, 0, canvas.width, canvas.height);
    scale = canvas.height / 700.0;
    w = canvas.width / scale;
    h = 700;
    c.scale(scale, scale);
    if (splash) {
        img("logo", w / 2, h * 0.6);
    } else if (epilogue) {
        img("lobby-bg", w / 2, h / 2);
        person(manager, w / 2, h / 2, false);
        img("lobby-fg", w / 2, h * 0.8);
        speech("Hotel Manager", epilogueLines[numSurvivors()], w / 2, h * 0.8);
        c.fillStyle = "#b3a221";
        c.fillRect(w / 2 - 100, 600, 200, 50);
        c.fillStyle = "#dac739";
        if (cursor.x / scale > w / 2 - 100 && cursor.x / scale < w / 2 + 100 && cursor.y / scale > 600 && cursor.y / scale < 650) {
            c.fillStyle = "#e2d363";
        }
        c.fillRect(w / 2 - 98, 602, 196, 46);
        c.fillStyle = "black";
        c.fillText("TRY AGAIN", w / 2 - c.measureText("TRY AGAIN").width / 2, 632);
        return;
    } else if (night) {
        img("rooms-night", w / 2, h / 2);
        c.translate(w / 2 - 500, 0);
        text("Survivors: " + numSurvivors(), 200, 350);
        for (var i = 0; i < rooms.length; i++) {
            var room = rooms[i];
            var occupant = room.occupant;
            c.translate(occupant.x, occupant.y);
            c.scale(occupant.xFlipForAnimation ? -0.2 : 0.2, 0.2);
            person(occupant, 0, 0, occupant.active);
            c.resetTransform();
            c.scale(scale, scale);
            c.translate(w / 2 - 500, 0);
        }
        if (tentacle) {
            img(tentacle, tentacleX, tentacleY + 500);
        }
        for (var i = 0; i < particles.length; i++) {
            var p = particles[i];
            c.fillStyle = p.color;
            if (p.letter) {
                whiteText(p.letter, p.x, p.y);
            } else {
                c.beginPath();
                c.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                c.fill();
            }
        }
    } else if (assignGuest) {
        img("rooms", w / 2, h / 2);
        c.translate(w / 2 - 500, 0);
        for (var i = 0; i < rooms.length; i++) {
            var room = rooms[i];
            if (room.occupant) {
                c.translate(room.x + room.w / 2, room.y + room.h * 3 / 4);
                c.scale(0.2, 0.2);
                person(room.occupant, 0, 0, false);
                c.resetTransform();
                c.scale(scale, scale);
                c.translate(w / 2 - 500, 0);
            } else if (cursor.x / scale > room.x + w / 2 - 500 && cursor.x / scale < room.x + room.w + w / 2 - 500 && cursor.y / scale > room.y && cursor.y / scale < room.y + room.h) {
                c.fillStyle = "rgba(255, 255, 255, 0.5)";
                c.fillRect(room.x, room.y, room.w, room.h);
            }
            speech(room.name, room.occupant ? room.occupant.name : "Empty", room.x + room.w / 2, room.y + room.h / 4);
        }
        c.resetTransform();
        c.translate(cursor.x, cursor.y);
        c.scale(scale * 0.2, scale * 0.2);
        person(guest, 0, 0, false);
    } else {
        if (intro) {
            img("lobby-bg", w / 2, h / 2);
            person(manager, w / 2, h / 2, false);
            img("lobby-fg", w / 2, h * 0.8);
            speech("Hotel Manager", introLines[introLine], w / 2, h * 0.8);
            return;
        }
        if (managerOut) {
            img("lobby-bg", w / 2, h / 2);
            person(manager, w / 2 + managerX, h / 2, false);
            img("lobby-fg", w / 2, h * 0.8);
            return;
        }
        img("lobby-bg", w / 2, h / 2);
        if (guestWait == 0) {
            person(guest, w / 2, h / 2, false);
        } else if (!guest.introParticles) {
            c.translate(w / 2, h / 2 + guestWait / 6);
            c.scale(1 - guestWait / 600, 1 - guestWait / 600);
            person(guest, 0, 0);
            c.resetTransform();
            c.scale(scale, scale);
        }
        for (var i = 0; i < particles.length; i++) {
            var p = particles[i];
            c.fillStyle = p.color;
            c.beginPath();
            c.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            c.fill();
        }
        img("lobby-fg", w / 2, h * 0.8);
        if (guestSaidHello) {
            speech(guest.name, guest.intro, w / 2, h * 0.8);
            c.fillStyle = "#b3a221";
            c.fillRect(w / 2 - 100, 600, 200, 50);
            c.fillStyle = "#dac739";
            if (cursor.x / scale > w / 2 - 100 && cursor.x / scale < w / 2 + 100 && cursor.y / scale > 600 && cursor.y / scale < 650) {
                c.fillStyle = "#e2d363";
            }
            c.fillRect(w / 2 - 98, 602, 196, 46);
            c.fillStyle = "black";
            c.fillText("ASSIGN ROOM", w / 2 - c.measureText("ASSIGN ROOM").width / 2, 632);
        }
    }
}

var canvas = document.getElementById("gameCanvas");
var c = canvas.getContext("2d");
var keys = {};
var click = null;
var mouseDown = false;
var cursor = {x: 300, y: 300};

// Listen for key presses.
function canvasKeyDown(e) {
    keys[String.fromCharCode(e.which)] = true;
}

function canvasKeyUp(e) {
    keys[String.fromCharCode(e.which)] = false;
}

function down(key) {
    return !!keys[key];
}

$('body').keydown(canvasKeyDown);
$('body').keyup(canvasKeyUp);

// Listen for mouse stuff.
function canvasClick(e) {
    click = { "x": e.offsetX, "y": e.offsetY };
}

function canvasMouseDown(e) {
    mouseDown = true;
}

function canvasMouseUp(e) {
    mouseDown = false;
}

function canvasMove(e) {
    cursor = { "x": e.offsetX, "y": e.offsetY };
}

$('#gameCanvas').click(canvasClick).mousemove(canvasMove).mousedown(canvasMouseDown).mouseup(canvasMouseUp);

// Set up game loop.
var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
var lastUpdate = new Date().getTime();

function nextFrame() {
    var currentTime = new Date().getTime();
    input(currentTime - lastUpdate);
    click = null;
    update(currentTime - lastUpdate);
    draw();
    lastUpdate = currentTime;
    requestAnimationFrame(nextFrame);
}

// Once everything is set up, start game loop.
requestAnimationFrame(nextFrame);

jQuery(window).resize(function() {
    canvas.width = window.innerWidth - 20;
    canvas.height = window.innerHeight - 20;
});
jQuery(window).ready(function() {
    canvas.width = window.innerWidth - 20;
    canvas.height = window.innerHeight - 20;
});
 
/*canvas.addEventListener("click", function() {
    if (canvas.webkitRequestFullScreen) {
        canvas.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
    } else if (canvas.mozRequestFullScreen) {
        canvas.mozRequestFullScreen();
    } else if (canvas.requestFullScreen) {
        canvas.requestFullScreen();
    }
});*/
        </script>
    </body>
</html>
